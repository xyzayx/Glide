
const esprima = require('esprima')
const escodegen = require('escodegen')

//---------------------------------------------------------------------------------------------------

var rand_char_str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
var rand_char_len = rand_char_str.length

function random_str(length){
    let result = ""

    for (let i = 0; i < length; i++) {
        result += rand_char_str.charAt(Math.floor(Math.random() * rand_char_len))
    }
    return result
}

function random_uniq_str(length = 10){
    return random_str(length) + "_" + Date.now()
}

function desc_sort(array, selector = ident){
    return array.sort((a, b) => selector(b) - selector(a))
}

function asc_sort(array, selector = ident){
    return array.sort((a, b) => selector(a) - selector(b))
}

//---------------------------------------------------------------------------------------------------

function gensym(prefix = false){
  prefix = prefix || 'G_'
  return prefix + random_uniq_str()
}

// Nodes means [{node, meta}, {node, meta}, ...] and not [node, node, node, ...]

function extract_nodes(source, predicate){
  let nodes = []
  esprima.parseScript(source, {}, (node, meta) => {
    if(predicate(node)) nodes.push({node, meta})
  })
  return nodes
}

function sort_nodes(nodes){
  return asc_sort(nodes, entry => entry.meta.start.offset)
}

function reverse_sort_nodes(nodes){
  return desc_sort(nodes, entry => entry.meta.end.offset)
}

function overwrite_node(node, source, node_to_source_fn){
  if (node.meta.start.offset < source.length && node.meta.end.offset <= source.length){
    source = source.slice(0, node.meta.start.offset) +
      node_to_source_fn(node) +
      source.slice(node.meta.end.offset)
  }
  return source
}

function overwrite_nodes(nodes, source, node_to_source_fn){
  nodes.forEach(node => source = overwrite_node(node, source, node_to_source_fn))
  return source
}

function erase_nodes(nodes, source){
  return overwrite_nodes(nodes, source, () => '')
}

function remove_nested_nodes(nodes){

  nodes = sort_nodes(nodes)

  let out = []
  let last_node_end = -1

  for (let node of nodes){
    if(node.meta.start.offset > last_node_end){
      out.push(node)
    }
    last_node_end = node.meta.end.offset
  }
  return out
}

//---------------------------------------------------------------------------------------------------

var macros = {}

//---------------------------------------------------------------------------------------------------

// Node means node. Not {node, entry}.

function is_defmacro(node) {
  return node.type === 'CallExpression' && node.callee.name === 'defmacro'
}

function is_macro_call(node, macs = macros) {
  return node.type === 'CallExpression' && macs.hasOwnProperty(node.callee.name)
}

//---------------------------------------------------------------------------------------------------

function macro_name(defmacro){
  return defmacro.node.arguments[0].value
}

function macro_fn_source(defmacro){
  return escodegen.generate(defmacro.node.arguments[1])
}

function macro_fn(defmacro){
  return eval(macro_fn_source(defmacro)) // jshint ignore:line
}

function has_nested_defmacros(defmacro){
  return extract_nodes(macro_fn_source(defmacro), is_defmacro).length > 0
}

function validate_defmacro(defmacro){
  if (has_nested_defmacros(defmacro)){
    throw new Error(`Macro "${name}" contains a nested defmacro. \n\
    Macro definitions cannot be nested. \n\
    However, a macro may expand to a string that contains defmacro.`)
  }
}

function macro_from(defmacro){
  validate_defmacro(defmacro) // will throw if invalid
  return {name: macro_name(defmacro), fn: macro_fn(defmacro)}
}

function macros_from(defmacros){
  let macros = {}
  defmacros.forEach(defmacro => {
    let macro = macro_from(defmacro)
    macros[macro.name] = macro.fn
  })
  return macros
}

function register_macro(defmacro){
  let macro = macro_from(defmacro)
  macros[macro.name] = macro.fn
  return macro.fn
}

function expand_macro_call(macro_call, macs = macros){

  const macro_args = macro_call.node.arguments.map(arg_node => {
    if (arg_node.type === 'TaggedTemplateExpression' && arg_node.tag.name === 'c') {
      return arg_node.quasi.quasis[0].value.cooked
    } else {
      return escodegen.generate(arg_node, {semicolons: false})
    }
  })

  const expanded_code = macs[macro_call.node.callee.name](...macro_args)

  return expanded_code
}

//---------------------------------------------------------------------------------------------------

function mex(source, all_defmacros = []){

  let defmacros = extract_nodes(source, is_defmacro)
  all_defmacros = all_defmacros.concat(defmacros)

  defmacros.forEach(register_macro)

  defmacros = reverse_sort_nodes(defmacros) 
  // reverse sorting ensures source locations dont change between erasures / replacements.
  source = erase_nodes(defmacros, source)

  let macro_calls = extract_nodes(source, is_macro_call)

  if(macro_calls.length > 0){
    let calls = remove_nested_nodes(macro_calls)
    calls = reverse_sort_nodes(calls)
    let expanded_source = overwrite_nodes(calls, source, expand_macro_call)
    return mex(expanded_source, all_defmacros) // nested calls must be handled recursively.
  }else{
    if(all_defmacros.length > 0){
      // Some way to notify of what macros were defined, since defmacros are removed from source.
      console.log(`%cMacros defined: ${all_defmacros.map(defmacro => defmacro.node.arguments[0].value)}`,
                  'color:green; background-color:rgba(30, 200, 90, 0.2); padding: 20px')
    }
    return source // no more nested calls, return source
  }

}

function mex1(source, all_defmacros = []){

  let defmacros = extract_nodes(source, is_defmacro)
  all_defmacros = all_defmacros.concat(defmacros)

  defmacros = reverse_sort_nodes(defmacros) 
  // reverse sorting ensures source locations dont change between erasures / replacements.
  source = erase_nodes(defmacros, source)

  let macros = macros_from(defmacros)
  let macro_calls = extract_nodes(source, macro_call => is_macro_call(macro_call, macros))

  if(macro_calls.length > 0){
    let calls = remove_nested_nodes(macro_calls)
    calls = reverse_sort_nodes(calls)
    let expanded_source = overwrite_nodes(calls, source, macro_call => expand_macro_call(macro_call, macros))
    return expanded_source
  }
  return source
}

//---------------------------------------------------------------------------------------------------

function replace_convenience_delims(str) {

  // Anywhere in the code, including inside strings, regexes or comments etc, 
  // the delims must be escaped to not create linting issues. 
  // Additionally within a string you must escape the escape.
  // So \\ in a string instead of \

  // Regular expression to match \⎡ ... \⎦ blocks
  const re = /\⎡([^\⎦]*)\⎦/g

  return str.replace(re, function(match, group1) {
    // Escape ` and \ characters
    let escaped = group1.replace(/\\/g, '\\\\').replace(/`/g, '\\`')
    // Replace with c` ... `
    return 'c`' + escaped + '`'
  });
}

function pre_process_code(code){
  return replace_convenience_delims(code)
}

function post_process_code(code){
  return code
}

function macroexpand(code) {
  return post_process_code(mex(pre_process_code(code)))
}

function macroexpand1(code) {
  return post_process_code(mex1(pre_process_code(code)))
}

module.exports = {macroexpand, macroexpand1, gensym}
