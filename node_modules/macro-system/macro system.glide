<div class="area javascript program gutters-shown" tabindex="-1" id="u6WTWt2WXb" marks="[&quot;UELt6brG9X_1686118150086&quot;]" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="javascript" style="" custom_style="clip-path: inset(0px);">macros_off() // turn off glides existing macro system so it doesnt interfere with the code here.</textarea></div>

<div class="area javascript program gutters-shown" tabindex="-1" id="vlrrRsmezL" marks="[&quot;UELt6brG9X_1686118150086&quot;]" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="javascript" style="" custom_style="clip-path: inset(0px);">var rand_char_str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
var rand_char_len = rand_char_str.length

function random_str(length){
    let result = ""

    for (let i = 0; i &lt; length; i++) {
        result += rand_char_str.charAt(Math.floor(Math.random() * rand_char_len))
    }
    return result
}

function random_uniq_str(length = 10){
    return random_str(length) + "_" + Date.now()
}

function desc_sort(array, selector = ident){
    return array.sort((a, b) =&gt; selector(b) - selector(a))
}

function asc_sort(array, selector = ident){
    return array.sort((a, b) =&gt; selector(a) - selector(b))
}

function gensym(prefix = false){
  prefix = prefix || 'G_'
  return prefix + random_uniq_str()
}</textarea></div>

<div class="area javascript program gutters-shown" tabindex="-1" id="tcDcca1GD1" marks="[&quot;UELt6brG9X_1686118150086&quot;]" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="javascript" style="" custom_style="clip-path: inset(0px);">var esprima = require('esprima')
var escodegen = require('escodegen')</textarea></div>

<div class="area javascript program gutters-shown" tabindex="-1" id="ewX206DJWA" marks="[&quot;UELt6brG9X_1686118150086&quot;]" style="" custom_style="width: 850px;" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="javascript" style="" custom_style="">// Nodes means [{node, meta}, {node, meta}, ...] and not [node, node, node, ...]

function extract_nodes(source, predicate){
  let nodes = []
  esprima.parseScript(source, {}, (node, meta) =&gt; {
    if(predicate(node)) nodes.push({node, meta})
  })
  return nodes
}

function sort_nodes(nodes){
  return asc_sort(nodes, entry =&gt; entry.meta.start.offset)
}

function reverse_sort_nodes(nodes){
  return desc_sort(nodes, entry =&gt; entry.meta.end.offset)
}

function overwrite_node(node, source, node_to_source_fn){
  if (node.meta.start.offset &lt; source.length &amp;&amp; node.meta.end.offset &lt;= source.length){
    source = source.slice(0, node.meta.start.offset) +
      node_to_source_fn(node) +
      source.slice(node.meta.end.offset)
  }
  return source
}

function overwrite_nodes(nodes, source, node_to_source_fn){
  nodes.forEach(node =&gt; source = overwrite_node(node, source, node_to_source_fn))
  return source
}

function erase_nodes(nodes, source){
  return overwrite_nodes(nodes, source, () =&gt; '')
}

function remove_nested_nodes(nodes){

  nodes = sort_nodes(nodes)

  let out = []
  let last_node_end = -1

  for (let node of nodes){
    if(node.meta.start.offset &gt; last_node_end){
      out.push(node)
    }
    last_node_end = node.meta.end.offset
  }
  return out
}

//---------------------------------------------------------------------------------------------------

var macros = {}

//---------------------------------------------------------------------------------------------------

// Node means node. Not {node, entry}.

function is_defmacro(node) {
  return node.type === 'CallExpression' &amp;&amp; node.callee.name === 'defmacro'
}

function is_macro_call(node, macs = macros) {
  return node.type === 'CallExpression' &amp;&amp; macs.hasOwnProperty(node.callee.name)
}

//---------------------------------------------------------------------------------------------------

function macro_name(defmacro){
  return defmacro.node.arguments[0].value
}

function macro_fn_source(defmacro){
  return escodegen.generate(defmacro.node.arguments[1])
}

function macro_fn(defmacro){
  return eval(macro_fn_source(defmacro)) // jshint ignore:line
}

function has_nested_defmacros(defmacro){
  return extract_nodes(macro_fn_source(defmacro), is_defmacro).length &gt; 0
}

function validate_defmacro(defmacro){
  if (has_nested_defmacros(defmacro)){
    throw new Error(`Macro "${name}" contains a nested defmacro. \n\
    Macro definitions cannot be nested. \n\
    However, a macro may expand to a string that contains defmacro.`)
  }
}

function macro_from(defmacro){
  validate_defmacro(defmacro) // will throw if invalid
  return {name: macro_name(defmacro), fn: macro_fn(defmacro)}
}

function macros_from(defmacros){
  let macros = {}
  defmacros.forEach(defmacro =&gt; {
    let macro = macro_from(defmacro)
    macros[macro.name] = macro.fn
  })
  return macros
}

function register_macro(defmacro){
  let macro = macro_from(defmacro)
  macros[macro.name] = macro.fn
  return macro.fn
}

function expand_macro_call(macro_call, macs = macros){

  const macro_args = macro_call.node.arguments.map(arg_node =&gt; {
    if (arg_node.type === 'TaggedTemplateExpression' &amp;&amp; arg_node.tag.name === 'c') {
      return arg_node.quasi.quasis[0].value.cooked
    } else {
      return escodegen.generate(arg_node, {semicolons: false})
    }
  })

  const expanded_code = macs[macro_call.node.callee.name](...macro_args)

  return expanded_code
}

//---------------------------------------------------------------------------------------------------

function mex(source, all_defmacros = []){

  let defmacros = extract_nodes(source, is_defmacro)
  all_defmacros = all_defmacros.concat(defmacros)

  defmacros.forEach(register_macro)

  defmacros = reverse_sort_nodes(defmacros) 
  // reverse sorting ensures source locations dont change between erasures / replacements.
  source = erase_nodes(defmacros, source)

  let macro_calls = extract_nodes(source, is_macro_call)

  if(macro_calls.length &gt; 0){
    let calls = remove_nested_nodes(macro_calls)
    calls = reverse_sort_nodes(calls)
    let expanded_source = overwrite_nodes(calls, source, expand_macro_call)
    return mex(expanded_source, all_defmacros) // nested calls must be handled recursively.
  }else{
    if(all_defmacros.length &gt; 0){
      // Some way to notify of what macros were defined, since defmacros are removed from source.
      console.log(`%cMacros defined: ${all_defmacros.map(defmacro =&gt; defmacro.node.arguments[0].value)}`,
                  'color:green; background-color:rgba(30, 200, 90, 0.2); padding: 20px')
    }
    return source // no more nested calls, return source
  }

}

function mex1(source, all_defmacros = []){

  let defmacros = extract_nodes(source, is_defmacro)
  all_defmacros = all_defmacros.concat(defmacros)

  defmacros = reverse_sort_nodes(defmacros) 
  // reverse sorting ensures source locations dont change between erasures / replacements.
  source = erase_nodes(defmacros, source)

  let macros = macros_from(defmacros)
  let macro_calls = extract_nodes(source, macro_call =&gt; is_macro_call(macro_call, macros))

  if(macro_calls.length &gt; 0){
    let calls = remove_nested_nodes(macro_calls)
    calls = reverse_sort_nodes(calls)
    let expanded_source = overwrite_nodes(calls, source, macro_call =&gt; expand_macro_call(macro_call, macros))
    return expanded_source
  }
  return source
}

//---------------------------------------------------------------------------------------------------

function replace_convenience_delims(str) {

  // Anywhere in the code, including inside strings, regexes or comments etc, 
  // the delims must be escaped to not create linting issues. 
  // Additionally within a string you must escape the escape.
  // So \\ in a string instead of \

  // Regular expression to match \⎡ ... \⎦ blocks
  const re = /\⎡([^\⎦]*)\⎦/g

  return str.replace(re, function(match, group1) {
    // Escape ` and \ characters
    let escaped = group1.replace(/\\/g, '\\\\').replace(/`/g, '\\`')
    // Replace with c` ... `
    return 'c`' + escaped + '`'
  });
}

function pre_process_code(code){
  return replace_convenience_delims(code)
}

function post_process_code(code){
  return code
}

function macroexpand(code) {
  return post_process_code(mex(pre_process_code(code)))
}

function macroexpand1(code) {
  return post_process_code(mex1(pre_process_code(code)))
}
</textarea></div>

<div class="area generic" tabindex="-1" id="byFL3Trh62" contenteditable="true" spellcheck="false" style="column-count: 1; font-size: 17px; text-align: center;" custom_style="column-count: 1; font-size: 17px; text-align: center;"><div><br></div>Testing&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<div><br></div></div>

<div class="area loader program gutters-shown" tabindex="-1" id="rcxNeupcLq" marks="[&quot;UELt6brG9X_1686118150086&quot;]" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="loader" style="" custom_style="clip-path: inset(0px);">[["/Users/varun/code/test.glide", true]]</textarea></div>

<div class="area javascript program gutters-shown" tabindex="-1" id="vU4Nj8blTp" marks="[&quot;UELt6brG9X_1686118150086&quot;]" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="javascript" style="" custom_style="clip-path: inset(0px);">var prettier = require('/Users/varun/jects/js-macro-system/node_modules/prettier')

function normalize(code) {
    code =  prettier.format(code, { semi: true, parser: "babel" }).trim()
    code = code.replace(/[\r\n]/g, ' ');
  	code = code.replace(/\s\s+/g, ' ');
    return code.trim()
}

function ntest(name, x, y){
  (test[name])(normalize(x), normalize(y))
}

let serial_number = 1
function slog(str){
  console.log(`%c${serial_number}: ${str}`, 'padding-top: 10px; border-top: 2px black solid; margin-top:5px')
  serial_number++
}

slog.reset = () =&gt; serial_number = 1</textarea></div>

<div class="area javascript program gutters-shown" tabindex="-1" id="G5EqkkipZ9" marks="[&quot;UELt6brG9X_1686118150086&quot;]" mark="UELt6brG9X_1686118150086"><textarea class="section code" mode="javascript" style="" custom_style="clip-path: inset(0px);">slog.reset()
//------------------------------------------------------------------------------------
// Testing gensym

slog('gensym')
test.not_equal(gensym(), gensym())

slog('gensym is standard')
test.match(gensym(), /G_\w{10}_\d+/i)

slog('gensym with prefix')
test.match(gensym("prefix"), /prefix\w{10}_\d+/i)

slog('gensym with empty string prefix')
test.match(gensym(""), /\w{10}_\d+/i)

slog('gensym with numeric prefix')
test.match(gensym(123), /123\w{10}_\d+/i)

slog('gensym uniqueness over multiple calls')
let gensyms = new Set()
for (let i = 0; i &lt; 1000; i++) {
  gensyms.add(gensym())
}
test.equal(gensyms.size, 1000)

//------------------------------------------------------------------------------------
// Testing extract_nodes

slog('extract_nodes')
test.subobject_equal(
  extract_nodes('let x = 5', node =&gt; node.type === 'Identifier'),
  [{ node: { type: 'Identifier', name: 'x' }, meta: { start: { offset: 4 }, end: { offset: 5 } } }]
)

slog('extract_nodes should not return empty results when node is present')
test.not_deep_equal(extract_nodes('let x = 5', node =&gt; node.type === 'Literal'), [])

slog('extract_nodes with complex code input')
test.subobject_equal(
  extract_nodes('for(let i=0; i&lt;10; i++) { console.log(i) }', node =&gt; node.type === 'Identifier'),
  'i,i,i,console,log,i'.split(',').map(x =&gt; {return {node: {name: x}}})
)

slog('extract_nodes with non-existing node type')
test.deep_equal(extract_nodes('let x = 5', node =&gt; node.type === 'NonExistType'), [])

//------------------------------------------------------------------------------------
// Testing sort_nodes

slog('sort_nodes')
let unsorted_nodes = [
  { node: {}, meta: { start: { offset: 5 }, end: { offset: 7 } } },
  { node: {}, meta: { start: { offset: 1 }, end: { offset: 2 } } },
  { node: {}, meta: { start: { offset: 3 }, end: { offset: 5 } } }
]
let sorted_nodes = [
  { node: {}, meta: { start: { offset: 1 }, end: { offset: 2 } } },
  { node: {}, meta: { start: { offset: 3 }, end: { offset: 5 } } },
  { node: {}, meta: { start: { offset: 5 }, end: { offset: 7 } } }
]
test.deep_equal(sort_nodes(unsorted_nodes), sorted_nodes)

slog('sort_nodes with single node array')
let single_node = [{ node: {}, meta: { start: { offset: 1 }, end: { offset: 2 } } }]
test.equal(sort_nodes(single_node), single_node)

slog('sort_nodes with empty array')
test.deep_equal(sort_nodes([]), [])

//------------------------------------------------------------------------------------
// Testing reverse_sort_nodes

slog('reverse_sort_nodes')
let reverse_sorted_nodes = [
  { node: {}, meta: { start: { offset: 5 }, end: { offset: 7 } } },
  { node: {}, meta: { start: { offset: 3 }, end: { offset: 5 } } },
  { node: {}, meta: { start: { offset: 1 }, end: { offset: 2 } } }
]
test.deep_equal(reverse_sort_nodes(unsorted_nodes), reverse_sorted_nodes)

slog('reverse_sort_nodes with single node array')
test.equal(reverse_sort_nodes(single_node), single_node)

slog('reverse_sort_nodes with empty array')
test.deep_equal(reverse_sort_nodes([]), [])

//------------------------------------------------------------------------------------
// Testing erase_nodes

slog('erase_nodes')
let nodes_to_remove = [
  { node: { type: 'Identifier', name: 'x' }, meta: { start: { offset: 4 }, end: { offset: 5 } } },
  { node: { type: 'Literal', value: 5 }, meta: { start: { offset: 8 }, end: { offset: 9 } } }
]
test.equal(erase_nodes(reverse_sort_nodes(nodes_to_remove), 'let x = 5'), 'let  = ')

slog('erase_nodes with no nodes to remove')
test.equal(erase_nodes([], 'let x = 5'), 'let x = 5')

slog('erase_nodes with source code as empty string')
test.equal(erase_nodes(nodes_to_remove, ''), '')

//------------------------------------------------------------------------------------
// Testing for remove_nested_nodes

slog('remove_nested_nodes')
let nodes_with_nested = [
  { node: {}, meta: { start: { offset: 1 }, end: { offset: 5 } } },
  { node: {}, meta: { start: { offset: 3 }, end: { offset: 4 } } }
]
let nodes_without_nested = [
  { node: {}, meta: { start: { offset: 1 }, end: { offset: 5 } } }
]
test.deep_equal(remove_nested_nodes(nodes_with_nested), nodes_without_nested)

slog('remove_nested_nodes with no nested nodes')
let nodes_no_nested = [
  { node: {}, meta: { start: { offset: 1 }, end: { offset: 2 } } },
  { node: {}, meta: { start: { offset: 3 }, end: { offset: 4 } } }
]
test.deep_equal(remove_nested_nodes(nodes_no_nested), nodes_no_nested)

slog('remove_nested_nodes with single node')
test.deep_equal(remove_nested_nodes([nodes_no_nested[0]]), [nodes_no_nested[0]])

slog('remove_nested_nodes with empty array')
test.deep_equal(remove_nested_nodes([]), [])

//------------------------------------------------------------------------------------
// Testing overwrite_node

slog('overwrite_node')
let node_to_overwrite = { node: { type: 'Identifier', name: 'x' }, meta: { start: { offset: 4 }, end: { offset: 5 } } }
test.equal(overwrite_node(node_to_overwrite, 'let x = 5', node =&gt; 'y'), 'let y = 5')

slog('overwrite_node with node not present in the source')
let absent_node = { node: { type: 'Identifier', name: 'z' }, meta: { start: { offset: 10 }, end: { offset: 11 } } }
test.equal(overwrite_node(absent_node, 'let x = 5', node =&gt; 'y'), 'let x = 5')

slog('overwrite_node with source code as empty string')
test.equal(overwrite_node(node_to_overwrite, '', node =&gt; 'y'), '')

//------------------------------------------------------------------------------------
// Testing overwrite_nodes

slog('overwrite_nodes')
let nodes_to_overwrite = [
  { node: { type: 'Identifier', name: 'x' }, meta: { start: { offset: 4 }, end: { offset: 5 } } },
  { node: { type: 'Literal', value: 5 }, meta: { start: { offset: 8 }, end: { offset: 9 } } }
]
test.equal(overwrite_nodes(nodes_to_overwrite, 'let x = 5', node =&gt; 'y'), 'let y = y')

slog('overwrite_nodes with no nodes to overwrite')
test.equal(overwrite_nodes([], 'let x = 5', node =&gt; 'y'), 'let x = 5')

slog('overwrite_nodes with source code as empty string')
test.equal(overwrite_nodes(nodes_to_overwrite, '', node =&gt; 'y'), '')

//------------------------------------------------------------------------------------
// Testing macroexpand

slog('macroexpand')
let repeat = `defmacro('repeat', (n, action) =&gt; \`for (let i = 0; i &lt; \${n}; i++) { \${action} }\`)
repeat(5, console.log('Hello'))`
let expected_repeat = `for (let i = 0; i &lt; 5; i++) { console.log('Hello') }`
ntest('equal', macroexpand(repeat), expected_repeat)

slog('macroexpand with gensym')
let gensym_macro = `defmacro('unique_symbol', () =&gt; \`var \${gensym()} = 'Unique Symbol'\`)
unique_symbol()`
let expansion = macroexpand(gensym_macro)
let nds = extract_nodes(expansion, node =&gt; node.type === 'Identifier')
eval(expansion) //jshint ignore:line
test.match(window[nds[0].node.name], 'Unique Symbol')

slog('macroexpand with simple macro with multiple actions')
let declog = `defmacro('declare_and_log', 
(variable, value) =&gt; \`let \${variable} = \${value}; console.log(\${variable})\`)
declare_and_log(x, 5)`
let expected_declog = `let x = 5; console.log(x)`
ntest('equal', macroexpand(declog), expected_declog)

slog('macroexpand with nested defmacro')
let nested_defmacros = `defmacro('outer', () =&gt; defmacro('inner', () =&gt; console.log('Hello')))`
test.throws(() =&gt; macroexpand(nested_defmacros))

slog('macroexpand should handle macro calls inside macros')
let nested_macro_calls = `defmacro('repeat', (n, action) =&gt; \`for (let i = 0; i &lt; \${n}; i++) { \${action} }\`)
defmacro('nested', () =&gt; \`repeat(5, console.log('Hello'))\`)
nested()`
let expected_nested_macro_calls = `for (let i = 0; i &lt; 5; i++) { console.log('Hello') }`
ntest('equal', macroexpand(nested_macro_calls), expected_nested_macro_calls)

slog('macroexpand with undefined macro')
let no_macros = `code_should_remain(); 
// well
unchanged('yeah')`
ntest('equal', macroexpand(no_macros), no_macros)

slog('macros overwrite')
let redef_macro = `defmacro('addOne', (x) =&gt; \`$\{x} + 1\`); defmacro('addOne', (x) =&gt; \`$\{x} + 2\`); addOne(1)`
let expected_redef = `1 + 2`
ntest('equal', macroexpand(expected_redef), expected_redef)

slog('macroexpand when defmacro is called without function argument')
const test_defmacro_no_func = `defmacro('noFunc')`
const expected_defmacro_no_func = ``
test.throws(() =&gt; macroexpand(test_defmacro_no_func))

slog('macroexpand string arg')
const test_string_arg = `defmacro('addOne', (x) =&gt; \`$\{x} + 1\`); addOne('one')`
const expected_string_arg = `'one' + 1`
ntest('equal', macroexpand(test_string_arg), expected_string_arg)

slog('macroexpand ignores excess arguments (like functions)')
const test_excess_args = `defmacro('addOne', (x) =&gt; \`$\{x} + 1\`); addOne(1, 2)`
const expected_excess_args = `1 + 1`
ntest('equal', macroexpand(test_excess_args), expected_excess_args)

slog('macroexpand with multiple macros')
const test_multiple_macros = `
defmacro('addOne', (x) =&gt; \`$\{x} + 1\`)
defmacro('subtractOne', (x) =&gt; \`$\{x} - 1\`)
addOne(3); subtractOne(3)
`
const expected_multiple_macros = `3 + 1; 3 - 1`
ntest('equal', macroexpand(test_multiple_macros), expected_multiple_macros)

slog('defmacro with function that references an external variable')
var external_var = 2 
const test_func_ref_external_var = `defmacro('addExternalVar', (x) =&gt; \`$\{x} + $\{external_var}\`); addExternalVar(3)`
const expected_func_ref_external_var = `3 + 2`
ntest('equal', macroexpand(test_func_ref_external_var), expected_func_ref_external_var)

slog('macroexpand when macro is invoked inside an if statement')
const test_macro_in_if = `defmacro('addOne', (x) =&gt; \`$\{x} + 1\`); if (true) { addOne(1) }`
const expected_macro_in_if = `if (true) { 1 + 1 }`
ntest('equal', macroexpand(test_macro_in_if), expected_macro_in_if)

slog('macroexpand when macro is invoked inside a for loop')
const test_macro_in_loop = `defmacro('addOne', (x) =&gt; \`$\{x} + 1\`); for (let i = 0; i &lt; 5; i++) { addOne(i) }`
const expected_macro_in_loop = `for (let i = 0; i &lt; 5; i++) { i + 1 }`
ntest('equal', macroexpand(test_macro_in_loop), expected_macro_in_loop)

slog('Macro for a simple swap operation')
const test_swap_macro = `
defmacro('swap', (x, y) =&gt; \`let temp = $\{x}; $\{x} = $\{y}; $\{y} = temp\`)
swap(a, b)
`
const expected_swap_macro = `let temp = a; a = b; b = temp`
ntest('equal', macroexpand(test_swap_macro), expected_swap_macro)

slog('Macro for a console.log operation with string formatting')
const test_log_format_macro = `
defmacro('logFormat', (msg, val) =&gt; \`console.log("$\{eval(msg)}: ", $\{val})\`)
logFormat("Value", 5)
`
const expected_log_format_macro = `
console.log("Value: ", 5)
`
ntest('equal', macroexpand(test_log_format_macro), expected_log_format_macro)

slog('Macro for a forEach operation on an array')
const test_foreach_print_macro = `
defmacro('forEachPrint', (arr) =&gt; \`$\{arr}.forEach((item) =&gt; console.log(item))\`)
forEachPrint([1, 2, 3])
`
const expected_foreach_print_macro = `
[1, 2, 3].forEach((item) =&gt; console.log(item))
`
ntest('equal', macroexpand(test_foreach_print_macro), expected_foreach_print_macro)

slog('Macro for an if-else operation')
const test_if_else_macro = `
defmacro('checkEven', (num) =&gt; \`if ($\{num} % 2 == 0) { console.log('Even') } else { console.log('Odd') }\`)
checkEven(3)
`
const expected_if_else_macro = `
if (3 % 2 == 0) { console.log('Even') } else { console.log('Odd') }
`
ntest('equal', macroexpand(test_if_else_macro), expected_if_else_macro)

slog('Macro for calculating factorial of a number')
const test_factorial_macro = `
defmacro('factorial', (num) =&gt; \`
  let result = 1
  for(let i = 2; i &lt;= $\{num}; i++)
      result *= i
  console.log(result)
\`)
factorial(5)
`
const expected_factorial_macro = `
  let result = 1
  for(let i = 2; i &lt;= 5; i++)
      result *= i
  console.log(result)
`
ntest('equal', macroexpand(test_factorial_macro), expected_factorial_macro)

slog('Anaphoric macro with evaluation')
const for_array = `defmacro('for_array', (array, for_body) =&gt; {
	return 
    \`for(let i = 0; i &lt; \${array}.length; i++){
    	\${for_body}
    }\`
})
let arr = [1, 2, 3, 'done']
let str = ''
for_array(arr, str += arr[i])
str
`
test.equal(eval(macroexpand(for_array)), '123done') // jshint ignore:line

slog("Macros expansion may contain defmacros, which is ok.")
let out_in = `defmacro('out', () =&gt; "defmacro('ins', () =&gt; 10)")
out()
ins()`
ntest('equal', macroexpand(out_in), '10')

slog("Repeat macro with block")
let expected_rep_out = `for (let i = 0; i &lt; 10; i++) { 
  if(i &gt; 3){
  	break
  }else{
	console.log("Iteration number is", i)
  }
}`

let rep_input = `
defmacro('repeat', (n, action) =&gt; \`for (let i = 0; i &lt; \${n}; i++) { \${action} }\`)
repeat(10, \⎡
  if(i &gt; 3){
  	break
  }else{
	console.log("Iteration number is", i)
  }
\⎦)
`
ntest('equal', macroexpand(rep_input), expected_rep_out)

slog("macroexpand1 and macroexpand should be same for most macros")
ntest('equal', macroexpand(rep_input), macroexpand1(rep_input))

slog("macroexpand1 basic test")
let mac1_input = `defmacro('outer', () =&gt; 'defmacro("inner", () =&gt; 10)')
outer()`
ntest('equal', macroexpand1(mac1_input), 'defmacro("inner", () =&gt; 10)')

slog("macroexpand1 and macroexpand should not be same for some macros")
let mac1_inp = `defmacro('outr', () =&gt; 'defmacro("innr", () =&gt; 10)')
outr()
innr()`
ntest('not_equal', macroexpand1(mac1_inp), macroexpand(mac1_inp))</textarea></div>

<xmeta name="default-width" content="950px"></xmeta><xmeta name="state" content="{&quot;all_mgroup_ids&quot;:[&quot;UELt6brG9X_1686118150086&quot;],&quot;active_mgroup_id&quot;:&quot;UELt6brG9X_1686118150086&quot;}"></xmeta>